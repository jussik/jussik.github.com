{"version":3,"sources":["workers/path.worker.ts","workers/path.worker.js"],"names":["Tesp","Tesp.PathEdge","Tesp.PathEdge.constructor","Tesp.PathNode","Tesp.PathNode.constructor"],"mappings":"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","file":"path.worker.js","sourcesContent":["/// <reference path=\"../_refs.ts\"/>\r\nmodule Tesp {\r\n    class PathEdge implements IPathEdge {\r\n        constructor(public target: PathNode, public cost: number, public type: string) { }\r\n    }\r\n    class PathNode implements IPathNode {\r\n        dist: number;\r\n        prev: PathNode;\r\n        prevEdge: PathEdge;\r\n        edges: PathEdge[];\r\n\r\n        constructor(public node: INode) {\r\n            this.dist = Infinity;\r\n        }\r\n    }\r\n\r\n    importScripts(\"common.js\");\r\n\r\n    onmessage = ev => {\r\n        var data: IPathWorkerData = ev.data;\r\n        var spellCost = 5;\r\n\r\n        // create nodes\r\n        var nodeMap: { [key: number]: PathNode } = {};\r\n        var feats = data.features.byName;\r\n        var nodes: PathNode[] = data.nodes\r\n            .filter(n => !feats[n.type].disabled && n !== data.source && n !== data.destination)\r\n            .map(n => nodeMap[n.id] = new PathNode(n));\r\n\r\n        var source = new PathNode(data.source);\r\n        source.dist = 0;\r\n        nodes.push(source);\r\n        nodeMap[data.source.id] = source;\r\n\r\n        var dest = new PathNode(data.destination);\r\n        nodes.push(dest);\r\n        nodeMap[data.destination.id] = dest;\r\n\r\n        var maxCost = Vec2.distance(data.source.pos, data.destination.pos);\r\n\r\n        // explicit edges (services)\r\n        nodes.forEach(n =>\r\n            n.edges = n.node.edges\r\n                .filter(e => !feats[e.destNode.type].disabled)\r\n                .map(e => new PathEdge(nodeMap[(e.srcNode === n.node ? e.destNode : e.srcNode).id], e.cost, n.node.type)));\r\n\r\n        // implicit edges (walking)\r\n        nodes.forEach(n =>\r\n            n.edges = n.edges.concat(nodes\r\n                .filter(n2 => n2 !== n && !n.edges.some(e => e.target === n2))\r\n                .map(n2 => new PathEdge(n2, Vec2.distance(n.node.pos, n2.node.pos), \"walk\"))\r\n                .filter(e => e.cost <= maxCost)));\r\n\r\n        // mark\r\n        if (data.mark != null && !feats[\"mark\"].disabled) {\r\n            var mn = new PathNode(data.mark);\r\n            mn.edges = nodes.filter(n => n !== source)\r\n                .map(n => new PathEdge(n, Vec2.distance(mn.node.pos, n.node.pos), \"walk\"))\r\n                .filter(e => e.cost < maxCost);\r\n            source.edges.push(new PathEdge(mn, spellCost, \"mark\"));\r\n            nodes.push(mn);\r\n        }\r\n\r\n        // intervention\r\n        nodes.forEach(n => {\r\n            var cell = Cell.fromPosition(n.node.pos);\r\n            data.areas.forEach(a => {\r\n                if (!feats[a.target.type].disabled) {\r\n                    if (Area.containsCell(a, cell)) {\r\n                        // node inside area, teleport to temple/shrine\r\n                        n.edges.push(new PathEdge(nodeMap[a.target.id], spellCost, a.target.type));\r\n                    } else {\r\n                        // node outside area, walk to edge\r\n                        var dist: number = Infinity;\r\n                        var closest: Vec2;\r\n                        a.rows.forEach(r => {\r\n                            // v is closest point (in cell units) from node to row\r\n                            var v = new Vec2(\r\n                                Math.max(Math.min(cell.x, r.x1 + r.width), r.x1),\r\n                                Math.max(Math.min(cell.y, r.y + 1), r.y));\r\n                            var alt = Vec2.distance(cell, v);\r\n                            if (alt < dist) {\r\n                                dist = alt;\r\n                                closest = v;\r\n                            }\r\n                        });\r\n                        var pos = Vec2.fromCell(closest.x, closest.y);\r\n                        var cost = Vec2.distance(n.node.pos, pos);\r\n                        if (cost < maxCost) {\r\n                            // new node to allow us to teleport once we're in the area\r\n                            var feat = data.features.byName[a.target.type];\r\n                            var name = `${feat.name} range of ${a.target.name}`;\r\n                            var an = new PathNode(new Node(name, name, pos, \"area\"));\r\n                            an.edges = [new PathEdge(nodeMap[a.target.id], spellCost, a.target.type)];\r\n                            nodes.push(an);\r\n                            n.edges.push(new PathEdge(an, cost, \"walk\"));\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        var q: PathNode[] = nodes.slice();\r\n        var overhead = data.features.nodeOverhead;\r\n\r\n        while (q.length > 0) {\r\n            q.sort((a, b) => b.dist - a.dist);\r\n            var u = q.pop();\r\n\r\n            for (var i = 0; i < u.edges.length; i++) {\r\n                var e = u.edges[i];\r\n                var v = e.target;\r\n                var alt = u.dist + e.cost + overhead;\r\n                if (alt < v.dist) {\r\n                    v.dist = alt;\r\n                    v.prev = u;\r\n                    v.prevEdge = e;\r\n                }\r\n            }\r\n        }\r\n\r\n        // lib.d.ts does not have window.postMessage(message)\r\n        (<Worker><any>self).postMessage(dest);\r\n    }\r\n}",null],"sourceRoot":"../ts"}